# Module: WarehouseMethods
#
# Toolbox for updating associated tables via Ruby. Methods work for Product, Category, and Location classes.
#
# Public Methods:
# + find
# + all
# + delete
# + save
# + insert

module WarehouseMethods
  
  # Private(ish): self.included
  # Makes methods within the WarehouseClassMethods module Class methods.
  #
  # Parameters:
  # + base : String
  #
  # Returns: 
  # String
  #
  # State Changes:
  # None.
   
  def self.included(base)
    base.extend WarehouseClassMethods
  end
  
### CLASS METHODS ###

    module WarehouseClassMethods
    
      # Public: .find
      # Returns a record from a given table, by searching for the record's unique primary key.
      #
      # Parameters:
      # + table_name  : String
      # + record_id   : Integer
      #
      # Returns: 
      # Object: The record's details, expressed as an Object.
      #
      # State Changes:
      # None.
      
      def find(table_name, record_id)
        results = DATABASE.execute("SELECT * FROM #{table_name} WHERE id = #{record_id}")
        record_details = results[0]
        self.new(record_details)
        
      end
      
      # #################################
      # UNSUCCESSFUL ATTEMPT AT FORMATTING METHOD TO HELP WITH SINATRA
      # #################################
      #
      # def all_formatted(table_name)
      #   results = DATABASE.execute("SELECT * FROM #{table_name}")
      #
      #   n = results.length
      #   x = 0
      #
      #   until x = n do
      #     record_details = results[x]
      #     placeholder_instance = self.new(record_details)
      #     placeholder_instance.list_attributes
      #   end
      # end
      # #################################
      # #################################
      
      # Public: .all
      # Returns all records in a given table.
      #
      # Parameters:
      # + table_name  : String
      #
      # Returns: 
      # Array: Array of all records in a given table, each expressed as a Hash.
      #
      # State Changes:
      # None.
      
      def all(table_name)
        DATABASE.execute("SELECT * FROM #{table_name}")
      end
      
      # Public: .delete
      # Deletes a specific record from a given table.
      #
      # Parameters:
      # + table_name
      # + record_id
      #
      # Returns: 
      # None.
      #
      # State Changes:
      # Alters associated table; deletes Object.
  
      def delete(table_name, record_id)
        DATABASE.execute("DELETE FROM #{table_name} WHERE id = #{record_id}")
      end
      
    end

### INSTANCE METHODS ###
  
def list_attributes
  attributes = []
  instance_variables.each do |i|
    attributes << i.to_s.delete("@")
  end
  
  attribute_string = attributes.join("\n")
  puts "#{attribute_string}"
end

  # Public: .save
  # Syncs an object's attributes with the database. 
  #
  # Parameters:
  # + table_name
  #
  # Returns: 
  # None.
  #
  # State Changes:
  # Alters associated record in table. 
    
  def save(table_name)
    attributes = []
  
    instance_variables.each do |i|
      attributes << i.to_s.delete("@")
    end
  
    query_components_array = []
  
    attributes.each do |a|
      value = self.send(a)
    
      if value.is_a?(Integer)
        query_components_array << "#{a} = #{value}"
      else
        query_components_array << "#{a} = '#{value}'"
      end
    end
     
    query_string = query_components_array.join(", ")
  
    DATABASE.execute("UPDATE #{table_name} SET #{query_string} WHERE id = #{id}")
  end

  # Public: .insert
  # Syntax to enter the Ruby object's arguments as a records' field values via sqlite3
  #
  # Parameters:
  #
  # Returns: 
  # Integer - @id, "id" field value, generated by table upon creation and pulled from the record
  # 
  # State Changed:
  # ???

  def insert(table_name)
    if table_name == "products"
      DATABASE.execute("INSERT INTO products (serial_number, description, 
                      quantity, cost, location_id, category_id) 
                      VALUES (#{@serial_number}, '#{@description}', 
                      #{@quantity}, #{@cost}, #{@location_id}, #{@category_id})")
    # At present, 0's are entered in for integer values that are not entered, need to change this to our default settings. Blank field left for empty text values.
      @id = DATABASE.last_insert_row_id
    elsif table_name == "locations"
      DATABASE.execute("INSERT INTO locations (city) VALUES ('#{@city}')")
      @id = DATABASE.last_insert_row_id
    elsif table_name == "categories"
      DATABASE.execute("INSERT INTO categories (name) VALUES ('#{@name}')")
      @id = DATABASE.last_insert_row_id            
    end
  end
end
